\documentclass{article}
\usepackage{amsmath, amssymb, mathrsfs, stmaryrd,amsthm}
\usepackage{array}
\usepackage{proof}
\usepackage{bussproofs}
\usepackage{tikz}
\newtheorem{lemma}{Lemma}
\usepackage{mathtools}    
\usepackage{fontspec}     
\usepackage{minted}    
\usepackage{listings}
\lstset{
  basicstyle=\ttfamily\scriptsize,
  breaklines=true,
  columns=fullflexible
}

     
\usetikzlibrary{cd}
\renewcommand{\baselinestretch}{1.2}


\title{Extend the Intuitionistic Logic Natural Deduction with Kolmogorov Double Negation}
\author{Yantian Yin \\ Yifei Che}
\date{}

\begin{document}



\maketitle

\section{Idea}

The key difference between intuitionistic logic and classical logic lies in the acceptance of the law of excluded middle. Our goal is to explore the connection between the two systems, showing that they are essentially equivalent under double negation translation.


\subsection{Nature Deduction}
For the natural deduction we have these rules for
 introduction and elimination.

\[
\infer[\land I]{\vdash A \land B}{\vdash A & \vdash B}
\hspace{3cm}
\infer[\land E_L]{\vdash A}{\vdash A \land B}
\quad
\infer[\land E_R]{\vdash B}{\vdash A \land B}
\]


% Row 2: →I, →E
\[
\infer[\supset I^u]{\vdash A \supset B}{
  \infer*{\vdash B}{\infer [u]{\vdash A}{}}
}
\hspace{3cm}
\infer[\supset E]{\vdash B}{\vdash A \supset B & \vdash A}
\]



% Row 3: ∨I, ∨E
\[
\infer[\lor I_L]{\vdash A \lor B}{\vdash A}
\quad
\infer[\lor I_R]{\vdash A \lor B}{\vdash B}
\hspace{2cm}
\infer[\lor E^{u_1, u_2}]{\vdash C}{
  \vdash A \lor B
  \quad
  \infer*{\vdash C}{\infer[u_1]{\vdash A}{}}
  \quad
  \infer*{\vdash C}{\infer[u_2]{\vdash B}{}}
}
\]

% Row 4: ¬I, ¬E
\[
\infer[\neg I^{p,u}]{\vdash \neg A}{
  \infer*{\vdash \perp}{\infer[u]{\vdash A}{}}
}
\hspace{3cm}
\infer[\neg E]{\vdash C}{
  \vdash A & \vdash \neg A
}
\]

% Row 5: ⊤I, ⊥E
\[
\infer[\top I]{\vdash \top}{}
\hspace{3cm}
\infer[\perp E]{\vdash C}{\vdash \perp}
\]
Natural deduction (ND) corresponds to intuitionistic logic because it does not enforce that every proposition has a fixed complement. For example, if we apply \emph{negation introduction} ($\neg I$) to a proposition $A$ and derive $\neg A$, we cannot simply repeat this process on $\neg A$ to recover $A$. This asymmetry is a key reason why ND is not classical logic.

To extend ND into classical logic, we need to incorporate the law of excluded middle. One way to do this is by adding the \emph{Kolmogorov double negation rule}, which allows us to derive $A$ from $\neg\neg A$. We refer to this rule as $\neg\text{kd}E$ (short for \emph{not Kolmogorov double Elimination}, or \textbf{nkdE}). With this rule added, we define a new system—ND plus the Kolmogorov rule—which we call \textbf{KND}.

To fully complete KND as classical logic, we must also specify the unique complement of $\top$, which is $\bot$. We treat $\bot$ as an atomic formula. With these additions, KND forms a proper classical logic system.

\[
\infer[\neg\neg_{kd}E]{\vdash A}{\vdash \neg\neg A}
\]

\begin{center}
    \fbox{%
  \begin{minipage}{0.8\textwidth}
\[
\infer[\neg\neg E]{\vdash A \lor \neg A}{
  \infer[\neg I^{p,u}]{\vdash \neg\neg(A\lor\neg A)}{
    \infer{\vdash p}{
      % First assumption subproof u
      \infer[u]{\vdash \neg(A\lor\neg A)}{}
      \quad
      % Disjunction introduction on ¬A
      \infer[\lor I_2]{\vdash A \lor \neg A}{
        % Nested negation introduction subproof p,ν
        \infer[\neg I^{p,\nu}]{\vdash \neg A}
        {
          \infer[\neg E]{\vdash p}{
            % Disjunction introduction on A
            \infer[u]{\vdash \neg(A\lor\neg A)}{}
            \quad
            % Reuse assumption u
            \infer[\lor I_1]{\vdash A \lor \neg A}{
              \infer[\nu]{\vdash A}{}
            }
          }
        }
      }
    }
  }
}
\]
\end{minipage}%
}
\\
\vspace{1em}
prove of excluding middle

\end{center}





Now in our hand we have the intuitionistic logic ND
 and classical logic KND. We show that both these two
  logics are "the same" by proving that for any logical formula provable in KND it can also be proven in ND (soundness) and any logical formula provable in ND can also be proven in KND (completeness).

To do this first we need to define a translation function that translates formulas in ND or KND to their counterparts. We use the ktrans--Kolmogorov translation and it is defined as ($n$ for $\neg\neg$):

\begin{align*}
A^* &= nA \quad \text{if } A \text{ is atomic} \\
(A \land B)^* &= n(A^* \land B^*) \\
(A \supset B)^* &= n(A^* \supset B^*) \\
(A \lor B)^* &= n(A^* \lor B^*) \\
(\neg A)^* &= n(\neg A^*) \\
\top^* &= n\top \\
\bot^* &= n\bot
\end{align*}




\section{Inference Rules}
Before we step into the proof of soundness and completeness we need some 
inference rules to help us eliminate double negation in ND.

First, since we can prove $\neg\neg A$ from $A$ in ND we 
have the inference rule $\neg\neg X$. Same with $\neg\neg_{k}X$.

Also we can eliminate $\neg\neg\neg A$ to $\neg A$, we make 
it as $\neg\neg\neg R$.

% First boxed derivation
\[
\infer[\neg I^{p,u}]{\vdash \neg\neg A}{
    \infer[\neg E]{\vdash p}{
        \infer [u]{\vdash \neg A}{} & \vdash A
    }
}
\quad \Rightarrow \quad
\fbox{$
    \infer[\neg \neg X]{\vdash \neg \neg A}{\vdash A}
$}
\]

% Second boxed derivation
\[
\infer[\neg kI^{p,u}]{\vdash \neg\neg A}{
    \infer[\neg kE]{\vdash p}{
        \infer [u]{\vdash \neg A}{} & \vdash A
    }
}
\quad \Rightarrow \quad
\fbox{$
    \infer[\neg \neg kX]{\vdash \neg \neg A}{\vdash A}
$}
\]

% Third boxed derivation
\[
    \infer[\neg I^{q,u}]{\vdash \neg A}{
        \infer[\neg E]{\vdash q}{ 
              \infer[\neg \neg X]{\vdash \neg \neg A}{\infer[u]{\vdash A}{}} &
              \infer[v]{\vdash \neg \neg \neg A}{}
        }
      }
\quad \Rightarrow \quad
\fbox{$
    \infer [\neg \neg \neg R]
    {\vdash \neg A}
    {\vdash \neg\neg \neg A} 
$}
\]

% Fourth boxed derivation
% Fourth boxed derivation  (re‑done for dneg_falser)
\[
\infer[\bot E]{\vdash C}{
  \infer[\neg E]{\vdash p}{
    \vdash \neg\neg\bot
    &
    \infer[\neg I^{u}]{\vdash \neg\bot}{
      \infer[u]{\vdash \bot}{}
    }
  }
}
\quad \Rightarrow \quad
\fbox{$
  \infer[\neg\neg\bot E]{\vdash C}{\vdash \neg\neg\bot}
$}
\]


\section{Lemma}
\begin{lemma}[Existence of Kolmogorov Translation]\label{lem:exists-kolm}
  For every propositional formula $A$ (built from atoms with
  $\neg$, $\land$, $\lor$, and $\supset$), there exists a formula
  $A^{\!*}$—its Kolmogorov translation—such that
  \[
    \operatorname{kolm}(A,A^{\!*})
  \]
  holds.
  \end{lemma}
  
  \begin{proof}
  Define $A^{\!*}$ by structural induction on $A$:
  \[
  \begin{array}{rcl@{\qquad}l}
  p^{\!*}              &\coloneqq& \neg\neg p &(\text{$p$ atomic})\\[4pt]
  \top^{\!*}           &\coloneqq& \top\\
  \bot^{\!*}           &\coloneqq& \bot\\[4pt]
  (A \land B)^{\!*}    &\coloneqq& \neg\neg\bigl(A^{\!*}\land B^{\!*}\bigr)\\
  (A \lor  B)^{\!*}    &\coloneqq& \neg\neg\bigl(A^{\!*}\lor  B^{\!*}\bigr)\\
  (A \supset B)^{\!*}  &\coloneqq& \neg\neg\bigl(A^{\!*}\supset B^{\!*}\bigr)\\
  (\neg A)^{\!*}       &\coloneqq& \neg\neg\neg A^{\!*}
  
  \end{array}
  \]
  
  \noindent
  \textbf{Base case.}  If $A$ is atomic ($A=p$), set $A^{\!*}=\neg\neg p$; then
  $\operatorname{kolm}(p,\neg\neg p)$ is immediate.
  
  \smallskip
  \noindent
  \textbf{Inductive step.}  Assume $A^{\!*}$ and $B^{\!*}$ already exist.
  The table above defines translations for each composite constructor,
  and the corresponding $\operatorname{kolm}$ derivations follow from
  the induction hypotheses.
  
  \smallskip
  Since the construction terminates for every syntax tree, the
  mapping $A\mapsto A^{\!*}$ is total; hence
  $\operatorname{kolm}(A,A^{\!*})$ holds for all formulas $A$.
  \end{proof}


  \begin{lemma}[Every Kolmogorov image is a double negation]
    \label{lem:outer-dneg}
    Let $A$ and $B$ be propositional formulas.
    If \(\operatorname{kolm}(A,B)\) holds, then there exists a formula
    \(C\) such that
    \[
       B \;=\; \neg\neg C
       \quad\text{and}\quad
       \operatorname{kolm}(A,C).
    \]
    \end{lemma}
    
    \begin{proof}
    Proceed by induction on the derivation of \(\operatorname{kolm}(A,B)\).
    
    \smallskip
    \emph{Atomic case.}  
    If \(A=p\) and the derivation ends with the rule for atoms, we have
    \(B=\neg\neg p\).  
    Set \(C:=p\).  
    Then \(\operatorname{kolm}(p,C)\) is the very last step of the given
    derivation, so the claim holds.
    
    \smallskip
    \emph{Conjunction.}  
    Suppose \(\operatorname{kolm}(A\land B_0,\,B)\) is derived via
    \[
       B \;=\; \neg\neg\bigl(D_1\land D_2\bigr),
       \qquad
       \operatorname{kolm}(A,D_1),
       \qquad
       \operatorname{kolm}(B_0,D_2).
    \]
    Take \(C := D_1\land D_2\).
    Both sub‑derivations satisfy the induction hypothesis, hence
    \(\operatorname{kolm}(A\land B_0,C)\) holds and
    \(B=\neg\neg C\).
    
    \smallskip
    \emph{Disjunction and implication.}  
    The arguments are identical: each rule in the definition of
    \(\operatorname{kolm}\) produces the outer pattern
    \(\neg\neg(\,\cdot\,)\), so we peel off that pair of negations and
    re‑assemble the inner sub‑translations using the induction hypothesis.
    
    \smallskip
    \emph{Negation.}  
    From \(\operatorname{kolm}(\neg A_0,B)\) we get
    \(B=\neg\neg\neg D\) with \(\operatorname{kolm}(A_0,D)\).
    Let \(C := \neg D\); then again \(B=\neg\neg C\) and
    \(\operatorname{kolm}(\neg A_0,C)\).
    
    \smallskip
    Thus every derivation of \(\operatorname{kolm}(A,B)\) factors through
    an inner formula \(C\) with \(B=\neg\neg C\), proving the claim.
    \end{proof}
    



\section{Soundness}

Now with the help of our derivation rule, and lemma we can prove our soundness theorem. We do structural proof on the last used operation.

\text{Case:}
\vspace{3em}
\[
\infer[\land kI]{A \land^k B}{A & B}
\quad \Rightarrow \quad
\infer[\neg\neg X]{\neg\neg(\neg\neg A \land \neg\neg B)}{
    \infer[\land I]{\neg\neg A \land \neg\neg B}{
      \neg\neg A & \neg\neg B
    }
}
\]

\vspace{3em}
\text{Case:}
\[
\infer[\land kE1]{A}{
  A \land^k B
}
\quad \Rightarrow \quad
\infer[\neg I^{p,v}]{ \neg \neg A}{ 
  \infer[\neg E]{ p}{
    \infer[u]{
        \neg \neg (\neg \neg A \land \neg \neg B)
     }{}
     \infer[]{
        \neg (\neg \neg A \land \neg \neg B)
     }{
        \infer[\neg I^{q,u}]{ q}{
            \infer[\land E1]{\neg \neg A }{
                \infer[u]{\neg \neg A \land \neg \neg B}{}
            }
            \infer[v]{\neg A}{}
        }
     }
  }
}
\]

\vspace{3em}
\text{Case:}
\[
\infer[\land kE2]{B}{
  A \land^k B
}
\quad \Rightarrow \quad
\infer[\neg I^{p,v}]{\neg \neg B}{ 
  \infer[\neg E]{p}{
    \infer[u]{
        \neg \neg (\neg \neg A \land \neg \neg B)
     }{}
     \infer[]{
        \neg (\neg \neg A \land \neg \neg B)
     }{
        \infer[\neg I^{q,u}]{ q}{
            \infer[\land E2]{\neg \neg B }{
                \infer[u]{\neg \neg A \land \neg \neg B}{}
            }
            \infer[v]{\neg B}{}
        }
     }
  }
}
\]

\vspace{3em}
\text{Case:}
\[
\infer[\supset k I^u]{A \supset^k B}{
  \infer*[]{B}{
    \infer[u]{A}{}
  }
}
\quad \Rightarrow \quad
\infer[\neg \neg X ] {\neg \neg(\neg \neg A \supset \neg \neg B )}{
\infer[\supset  I^u]{\neg \neg A \supset \neg \neg B}{
  \infer*[]{\neg \neg B}{
    \infer[u]{\neg \neg A}{}
  }
}
}
\]

\vspace{3em}
\text{Case:}
\[
\infer[\supset kE]{B}{
    A \supset^k B & A
}
\quad \Rightarrow \quad
\infer[\neg I^{q,v}] {\neg \neg B }{
\infer[\neg E]{q}{
    \infer[u]{\neg \neg(\neg \neg A \supset \neg \neg B )}{}
    \infer[\neg I^{p,u}]{\neg(\neg \neg A \supset \neg \neg B )}{
        \infer[\neg E]{p}{
            \infer[\supset E]{\neg \neg B}{
                \infer[u]{\neg \neg A \supset \neg \neg B}{}
                {\neg \neg A}
            }
            \infer[v]{\neg B}{}
        }
    }
}
}
\]


\vspace{3em}
\text{Case:}
\[
\infer[\lor kI1]{A \lor^k B}{A}
\quad \Rightarrow \quad
\infer[\neg \neg X]{\neg \neg(\neg \neg A \lor \neg \neg B)}{
    \infer[\lor I1]{\neg \neg A \lor \neg \neg B}{\neg \neg A
        \infer[]{}{}
    }
}
\]

\vspace{3em}
\text{Case:}
\[
\infer[\lor kI2]{A \lor^k B}{B}
\quad \Rightarrow \quad
\infer[\neg \neg X]{\neg \neg(\neg \neg A \lor \neg \neg B)}{
    \infer[\lor I2]{\neg \neg A \lor \neg \neg B}{\neg \neg B
        \infer[]{}{}
    }
}
\]


\vspace{3em}
\text{Case:}
\[
\infer[\lor kE^{u,v}]{C}{
    {A \lor^{k} B}
    \hspace{2em}
    \infer*[]{C}{\infer[u]{A}{}}
    \hspace{2em}
    \infer*[]{C}{\infer[v]{B}{}}
}
\quad\Longrightarrow\quad
\infer[\lor E^{u,v}]{\neg\neg C}{
    \infer[\neg\neg E]{\neg\neg A \;\lor\; \neg\neg B}{
        \neg\neg\!\bigl(\neg\neg A \lor \neg\neg B\bigr)}
    \hspace{2em}
    \infer*[]{\neg\neg C}{
        \infer[u]{\neg\neg A}{}}
    \hspace{2em}
    \infer*[]{\neg\neg C}{
        \infer[v]{\neg\neg B}{}}
}
\]





\vspace{3em}
\text{Case:}
\[
\infer[\neg\neg E]{A}{
    \neg\neg A
}
\quad \Rightarrow \quad
\infer[\neg\neg\neg R]{\neg \neg A}{
    \neg\neg\neg\neg A
}
\]

\vspace{3em}
\text{Case:}
\[
\infer[\neg\neg E]{A}{
    \neg\neg A
}
\quad \Rightarrow \quad
\infer[\neg\neg\neg R]{\neg \neg A}{
    \neg\neg\neg\neg A
}
\]



















\section{Completeness}
lemma 1: nd A -> knd A
\\
lemma 2: if have ktrans A A* then if we can proof knd A* then we can proof knd A





\section{Beluga}
\begin{lstlisting}
  i : type. % Type of individuals; we leave elements abstract.

  LF o : type =  % formulas
    | ⊃ : o -> o -> o
    | ⊤ : o
    | ⊥ : o
    | ∧   : o → o → o
    | ∨   : o → o → o
    | ¬  : o -> o
    | ∀  : (i → o) → o     % ∀ \x. A(x) ⊃ B    ∀ \x. A(x) ⊃ B(x) 
    | ∃  : (i → o) → o     % ∃ \x. A(x) ⊃ B    ∃ \x. A(x) ⊃ B(x) 
  ;
  
  --prefix ¬ 10. 
  --infix ∧ 6 right. 
  --infix ∨ 5 right. 
  --infix ⊃ 4 right.
  --prefix ∀ 8. 
  --prefix ∃ 8.
  
  
  LF nd : o -> type = 
    | ⊃I : (nd A -> nd B)
     -> nd (A ⊃ B)
           
    | ⊃E : nd (A ⊃ B) -> nd A 			  
     -> nd B
           
    | ¬I : ({p:o} nd A -> nd p)
     -> nd (¬ A)
           
    | ¬E : nd (¬ A) -> nd A
     -> nd C
           
    | ∧I : nd A → nd B
     → nd  (A ∧ B)
           
    | ∧El : nd (A ∧ B)
      → nd A
  
    | ∧Er : nd (A ∧ B)
      → nd B
  
    | ∨Il : nd A
      → nd (A ∨ B)
    | ∨Ir : nd B → nd (A ∨ B)
    | ∨E  :  nd (A ∨ B)
          → (nd A → nd C)
          → (nd B → nd C)        
          → nd C
    | ⊤I : nd ⊤
    | ⊥E : nd ⊥
           → nd C
  ;
  
     
  LF knd : o → type = 
    | ⊃kI : (knd A → knd B)
           → knd (A ⊃ B)
    
    | ⊃kE : knd (A ⊃ B) → knd A
            → knd B
    
    | ∧kI   : knd A → knd B
           → knd (A ∧ B)
    
    | ∧kEl  : knd (A ∧ B)
           → knd A
    
    | ∧kEr  : knd (A ∧ B)
           → knd B
    
    | ∨kIl  : knd A
           → knd (A ∨ B)
    
    | ∨kIr  : knd B
           → knd (A ∨ B)
    
    | ∨kE   : knd (A ∨ B)
           → (knd A → knd C)
           → (knd B → knd C)
           → knd C
    
    | ⊤kI   : knd ⊤
    
    | ⊥kE : knd ⊥
           → knd C
    
    | ¬kI   : ({p:o} knd A → knd p)
              → knd (¬ A)
  
    | ¬kE : knd (¬ A) -> knd A
           -> knd C
               
    | ¬¬kE  : knd (¬ (¬ A))
              → knd A
  ;
  
  LF ktrans : o -> o -> type =
    | ktrans_∧I : ktrans A A* -> ktrans B B* -> 
                 ktrans (A ∧ B) (¬ (¬ (A* ∧ B*)))
  
    | ktrans_∧El : ktrans (A ∧ B) (¬ (¬ (A* ∧ B*))) ->
                   ktrans A A*
  
    | ktrans_∧Er : ktrans (A ∧ B) (¬ (¬ (A* ∧ B*))) ->
                   ktrans B B*
  
    | ktrans_⊃I : ktrans A A* -> ktrans B B* -> 
                 ktrans (A ⊃ B) (¬ (¬ (A* ⊃ B*)))
  
    | ktrans_⊃E : ktrans (A ⊃ B) (¬ (¬ (A* ⊃ B*))) -> ktrans A A* ->
                 ktrans B B*
  
    | ktrans_∨I : ktrans A A* -> ktrans B B* -> 
                 ktrans (A ∨ B) (¬ (¬ (A* ∨ B*)))
    
    | ktrans_∨E : ktrans (A ∨ B) (¬ (¬ (A* ∨ B*))) -> ktrans A A* -> ktrans B B* -> ktrans C C* ->
                 ktrans C C*
  
    | ktrans_¬I : ktrans A A* ->
                 ktrans (¬ A) (¬ (¬ (¬ A*)))
    
    | ktrans_¬E : ktrans (¬ A) (¬ (¬ (¬ A*))) -> ktrans A A* -> ktrans C C* ->
                 ktrans C C*
  
    | ktrans_⊤ : ktrans ⊤ (¬ (¬ ⊤))
    
    | ktrans_⊥ : ktrans ⊥ (¬ (¬ ⊥))
  ;
  
  %{
  
  Translation context
  
  }%
  schema ctx = knd A ;
  schema nctx = nd A ;
  
  inductive Rel : {Γ:ctx} {Γ' : nctx} ctype =
    | empty : Rel [ ] [ ]
    | cons  : Rel [Γ] [Γ']
              → Rel [Γ, a:knd A[]] [Γ', a:nd A[]];
  
  rec ktrans_of : [⊢ o] → [⊢ o] =
  fn A =>
    case A of
      | [⊢ A1 ∧ B1] =>
          let [⊢ A1*] = ktrans_of [⊢ A1] in
          let [⊢ B1*] = ktrans_of [⊢ B1] in
          [⊢ ¬ (¬ (A1* ∧ B1*))]
      | [⊢ A1 ⊃ B1] =>
          let [⊢ A1*] = ktrans_of [⊢ A1] in
          let [⊢ B1*] = ktrans_of [⊢ B1] in
          [⊢ ¬ (¬ (A1* ⊃ B1*))]
      | [⊢ A1 ∨ B1] =>
          let [⊢ A1*] = ktrans_of [⊢ A1] in
          let [⊢ B1*] = ktrans_of [⊢ B1] in
          [⊢ ¬ (¬ (A1* ∨ B1*))]
      | [⊢ ¬ A1] =>
          let [⊢ A1*] = ktrans_of [⊢ A1] in
          [⊢ ¬ (¬ (¬ A1*))]
      | [⊢ ⊤] =>
          [⊢ ¬ (¬ ⊤)]
      | [⊢ ⊥] =>
          [⊢ ¬ (¬ ⊥)]
      
  ;
  
  rec existsktrans : {A : [⊢ o]} {A* : [⊢ o]} [⊢ ktrans A A*] = 
  mlam A => mlam A* =>
    case [⊢ A] of
    | [⊢ A1 ∧ B1] =>
      (case [⊢ A*] of
      | [⊢  ¬ (¬ (A1* ∧ B1*))] =>
        let [⊢ KA] = existsktrans [⊢ A1] [⊢ A1*] in
        let [⊢ KB] = existsktrans [⊢ B1] [⊢ B1*] in
        [⊢ ktrans_∧I KA KB])
    | [⊢ A1 ⊃ B1] =>
      (case [⊢ A*] of
      | [⊢  ¬ (¬ (A1* ⊃ B1*))] =>
        let [⊢ KA] = existsktrans [⊢ A1] [⊢ A1*] in
        let [⊢ KB] = existsktrans [⊢ B1] [⊢ B1*] in
        [⊢ ktrans_⊃I KA KB])
    | [⊢ A1 ∨ B1] =>
      (case [⊢ A*] of
      | [⊢  ¬ (¬ (A1* ∨ B1*))] =>
        let [⊢ KA] = existsktrans [⊢ A1] [⊢ A1*] in
        let [⊢ KB] = existsktrans [⊢ B1] [⊢ B1*] in
        [⊢ ktrans_∨I KA KB])
    | [⊢ ¬ A1] =>
      (case [⊢ A*] of
      | [⊢  ¬ (¬ (¬ A1*))] =>
        let [⊢ KA] = existsktrans [⊢ A1] [⊢ A1*] in
        [⊢ ktrans_¬I KA])
    | [⊢ ⊤] =>
      (case [⊢ A*] of
      | [⊢ ¬ (¬ ⊤)] =>
        [⊢ ktrans_⊤])
    | [⊢ ⊥] =>
      (case [⊢ A*] of
      | [⊢ ¬ (¬ ⊥)] =>
        [⊢ ktrans_⊥])
  ;
  
  rec dnotx : Rel [Γ] [Γ'] → [Γ' ⊢ nd A] → [Γ' ⊢ nd (¬ (¬ A))] =
  fn rel => fn prf =>
    let [Γ' ⊢ D[]] = prf in
    [Γ' ⊢ ¬I (\p. \u. ¬E u D[])]
  ;
  
  rec triple_neg_red : Rel [Γ] [Γ'] → [Γ' ⊢ nd (¬ (¬ (¬ A[])))] → [Γ' ⊢ nd (¬ A[])] =
  fn rel => fn prf =>
    let [Γ' ⊢ D[]] = prf in
    [Γ' ⊢ ¬I (\p. \u. ¬E D[] (¬I (\q. \v. ¬E v u)))]
  ;
  
  rec dneg_falser : Rel [Γ] [Γ'] → [Γ' ⊢ nd (¬ (¬ ⊥))] → [Γ' ⊢ nd C[]] =
  fn rel => fn prf =>
    let [Γ' ⊢ D[]] = prf in
    [Γ' ⊢ ¬E D[] (¬I \p. \u. (⊥E u))]
  ;
  
  rec sound : Rel [Γ] [Γ'] → [Γ ⊢ knd A[]] → [ ⊢ ktrans A A*] → [Γ' ⊢ nd A*[]] =
  fn rel => fn prf => fn kolm =>
    case (prf, kolm) of
    | ([Γ ⊢ ∧kI NKA NKB], [ ⊢ ktrans_∧I KA KB]) =>
      let [Γ' ⊢ NJA] = sound rel [Γ ⊢ NKA] [ ⊢ KA] in
      let [Γ' ⊢ NJB] = sound rel [Γ ⊢ NKB] [ ⊢ KB] in
      dnotx rel [Γ' ⊢ ∧I NJA NJB]
    | ([Γ ⊢ ∧kEl (NK1 : knd (A[] ∧ B[]))], [⊢ (KA : (ktrans A (¬(¬ A**))))]) =>
      let [⊢ B*] = ktrans_of [⊢ B] in
      let [⊢ KB] = existsktrans [⊢ B] [⊢ B*] in
      let [Γ' ⊢ NJ1[]] = sound rel [Γ ⊢ NK1] [⊢ ktrans_∧I KA KB] in
      [Γ' ⊢ ¬I (\p. \u.
        ¬E NJ1[] (
          ¬I (\q. \v.
            ¬E (∧El v) u)))]
    | ([Γ ⊢ ∧kEr (NK1 : knd (A[] ∧ B[]))], [⊢ (KB : (ktrans B (¬(¬ B**))))]) =>
      let [⊢ A*] = ktrans_of [⊢ A] in
      let [⊢ KA] = existsktrans [⊢ A] [⊢ A*] in
      let [Γ' ⊢ NJ1[]] = sound rel [Γ ⊢ NK1] [⊢ ktrans_∧I KA KB] in
      [Γ' ⊢ ¬I (\p. \u.
        ¬E NJ1[] (
          ¬I (\q. \v.
            ¬E (∧Er v) u)))]
    | ([Γ ⊢ ⊃kI \u. (NKB : knd B[])], [⊢ ktrans_⊃I (KA : (ktrans A A*)) (KB : (ktrans B B*))]) =>
      let [Γ', v:nd A*[] ⊢ v] = sound (cons rel) [Γ, u:knd A[] ⊢ u] [⊢ KA] in
      let [Γ', v:nd A*[] ⊢ NJB] = sound (cons rel) [Γ, u:knd _ ⊢ NKB] [⊢ KB] in
      dnotx rel [Γ' ⊢ ⊃I \u. NJB]
    | ([Γ ⊢ ⊃kE (NKI : knd (A[] ⊃ B[])) (NKA : knd A[])], [⊢ (KB : (ktrans B (¬(¬ B**))))]) =>
      let [⊢ A*] = ktrans_of [⊢ A] in
      let [⊢ KA] = existsktrans [⊢ A] [⊢ A*] in
      let [Γ' ⊢ NJA[]] = sound rel [Γ ⊢ NKA] [⊢ KA] in
      let [Γ' ⊢ NJI[]] = sound rel [Γ ⊢ NKI] [⊢ ktrans_⊃I KA KB] in
      [Γ' ⊢ ¬I (\p. \u.
        ¬E NJI[] (
          ¬I (\q. \v. 
            ¬E (⊃E v NJA[]) u)))]
    | ([Γ ⊢ ∨kIl NK], [⊢ ktrans_∨I KA KB]) =>
      let [Γ' ⊢ NJ] = sound rel [Γ ⊢ NK] [⊢ KA] in
      dnotx rel [Γ' ⊢ ∨Il NJ]
    | ([Γ ⊢ ∨kIr NK], [⊢ ktrans_∨I KA KB]) =>
      let [Γ' ⊢ NJ] = sound rel [Γ ⊢ NK] [⊢ KB] in
      dnotx rel [Γ' ⊢ ∨Ir NJ]
    | ([Γ ⊢ ∨kE (NK[] : knd (A[] ∨ B[])) (\ua. NKA[]) (\ub. NKB[])],[⊢ ktrans_∨E (KO : (ktrans (A ∨ B) (¬ (¬ (¬(¬ A**) ∨ ¬(¬ B**)))))) (KA : (ktrans A (¬(¬ A**)))) (KB : (ktrans B (¬(¬ B**)))) (KC : (ktrans C (¬(¬ C**))))]) =>
      let [Γ' ⊢ NJ[]] = sound rel [Γ ⊢ NK[]] [⊢ KO] in
      let [Γ', va:nd (¬(¬ A**[])) ⊢ va] = sound (cons rel) [Γ, ua:knd A[] ⊢ ua] [⊢ KA] in
      let [Γ', vb:nd (¬(¬ B**[])) ⊢ vb] = sound (cons rel) [Γ, ub:knd B[] ⊢ ub] [⊢ KB] in
      let [Γ', va:nd (¬(¬ A**[])) ⊢ NJA[]] = sound (cons rel) [Γ, ua:knd A[] ⊢ NKA[]] [⊢ KC] in
      let [Γ', vb:nd (¬(¬ B**[])) ⊢ NJB[]] = sound (cons rel) [Γ, ub:knd B[] ⊢ NKB[]] [⊢ KC] in
      [Γ' ⊢ ¬I (\p. \u.
        ¬E NJ[] (
          ¬I (\q. \v.
            ¬E (∨E v (\va. NJA[]) (\vb.NJB[])) u)))]
    %{| ([Γ ⊢ ¬kI \p. \u. NK1], [⊢ ktrans_¬I (K : (ktrans A A*))]) =>
      let [⊢ kp] = existsktrans [⊢ ⊥] [⊢ ¬ (¬ ⊥)] in
      let [Γ', v: nd A*[] ⊢ v] = sound (cons rel) [Γ, u:knd A[] ⊢ u] [⊢ K] in
      let [Γ', v: nd A*[] ⊢ NJ1[..,_,_]] = sound (cons rel) [Γ, u: knd A[] ⊢ NK1[..,⊥,_]] [⊢ kp] in
      let [Γ' ⊢ NJ1N[]] = dneg_falser rel [Γ'⊢ NJ1] in
      dnotx rel [Γ' ⊢ ¬I (\p. \u. NJ1N[..,p])]}%
    | ([Γ ⊢ ¬kE NK1[] (NK2[] : knd A[])], [⊢ ktrans_¬E (KN : (ktrans (¬ A) (¬ (¬ (¬ A*))))) (KA : (ktrans A A*)) (KC : (ktrans C C*))]) =>
      let [Γ' ⊢ NJ1] = sound rel [Γ ⊢ NK1[]] [⊢ KN] in
      let [Γ' ⊢ NJ2] = sound rel [Γ ⊢ NK2[]] [⊢ KA] in
      let [Γ' ⊢ NJ1'] = triple_neg_red rel [Γ' ⊢ NJ1] in
      [Γ' ⊢ ¬E NJ1' NJ2]
  ;
  
  rec nj_nk : Rel [Γ] [Γ'] → [Γ' ⊢ nd A[]] → [Γ ⊢ knd A[]] = 
  fn rel => fn prf =>
    case prf of
    | [Γ' ⊢ ∧I NJA NJB] =>
      let [Γ ⊢ NKA] = nj_nk rel [Γ' ⊢ NJA] in
      let [Γ ⊢ NKB] = nj_nk rel [Γ' ⊢ NJB] in
      [Γ ⊢ ∧kI NKA NKB]
    | [Γ' ⊢ ∧El NJ] =>
      let [Γ ⊢ NK] = nj_nk rel [Γ' ⊢ NJ] in
      [Γ ⊢ ∧kEl NK]
    | [Γ' ⊢ ∧Er NJ] =>
      let [Γ ⊢ NK] = nj_nk rel [Γ' ⊢ NJ] in
      [Γ ⊢ ∧kEr NK]
    | [Γ' ⊢ ⊃I \u. NJ] =>
      let [Γ, a: knd A[] ⊢ NK] = nj_nk (cons rel) [Γ', a:nd _ ⊢ NJ] in
      [Γ ⊢ ⊃kI \u. NK]
    | [Γ' ⊢ ⊃E NJI NJA] =>
      let [Γ ⊢ NKI] = nj_nk rel [Γ' ⊢ NJI] in
      let [Γ ⊢ NKA] = nj_nk rel [Γ' ⊢ NJA] in
      [Γ ⊢ ⊃kE NKI NKA]
    | [Γ' ⊢ ∨Il NJ] =>
      let [Γ ⊢ NK] = nj_nk rel [Γ' ⊢ NJ] in
      [Γ ⊢ ∨kIl NK]
    | [Γ' ⊢ ∨Ir NJ] =>
      let [Γ ⊢ NK] = nj_nk rel [Γ' ⊢ NJ] in
      [Γ ⊢ ∨kIr NK]
    | [Γ' ⊢ ∨E NJ (\ua. NJ1) (\ub. NJ2)] =>
      let [Γ ⊢ NK] = nj_nk rel [Γ' ⊢ NJ] in
      let [Γ, a: knd A[] ⊢ NK1] = nj_nk (cons rel) [Γ', a:nd _ ⊢ NJ1] in
      let [Γ, a: knd B[] ⊢ NK2] = nj_nk (cons rel) [Γ', a:nd _ ⊢ NJ2] in
      [Γ ⊢ ∨kE NK (\va.NK1) (\vb.NK2)]
    %{| [Γ' ⊢ ¬I \p. \u. NJ] =>
      let [Γ, a: knd A[] ⊢ NK] = nj_nk (cons rel) [Γ', a:nd _ ⊢ NJ[..]] in
      [Γ' ⊢ ⊃kI \q. \v. NK]}%
    | [Γ' ⊢ ¬E NJ1 NJ2] =>
      let [Γ ⊢ NK1] = nj_nk rel [Γ' ⊢ NJ1] in
      let [Γ ⊢ NK2] = nj_nk rel [Γ' ⊢ NJ2] in
      [Γ ⊢ ¬kE NK1 NK2]
  ;
  
  rec equiv : Rel [Γ] [Γ'] → [⊢ ktrans A A*] → [Γ ⊢ knd A*[]] → [Γ ⊢ knd A[]] =
  fn rel => fn kolm => fn prf =>
    case (kolm, prf) of
    | ([⊢ ktrans_∧I KA KB], [Γ ⊢ (u : knd (¬(¬(A* ∧ B*))))]) =>
      let [Γ ⊢ NKA] = equiv rel [⊢ KA] [Γ ⊢ ∧kEl (¬¬kE u)] in 
      let [Γ ⊢ NKB] = equiv rel [⊢ KB] [Γ ⊢ ∧kEr (¬¬kE u)] in
      [Γ ⊢ ∧kI NKA NKB]
  ;
\end{lstlisting}




















\end{document}