\documentclass{article}
\usepackage{amsmath, amssymb, mathrsfs, stmaryrd,amsthm}
\usepackage{array}
\usepackage{proof}
\usepackage{bussproofs}
\usepackage{tikz}
\newtheorem{lemma}{Lemma}
\usepackage{mathtools}    
\usepackage{fontspec}     
\usepackage{minted}    
\usepackage{listings}
\lstset{
  basicstyle=\ttfamily\scriptsize,
  breaklines=true,
  columns=fullflexible
}

     
\usetikzlibrary{cd}
\renewcommand{\baselinestretch}{1.2}


\title{Extend the Intuitionistic Logic Natural Deduction with Kolmogorov Double Negation}
\author{Yantian Yin \\ Yifei Che}
\date{}

\begin{document}



\maketitle

\section{Introduction}

Kolmogorov's double-negation translation provides a powerful method for interpreting classical logic within the framework of intuitionistic logic. This translation allows classical theorems to be rephrased in a form acceptable to constructive reasoning, bridging the gap between two foundational views of logic. 

Previous work by Brown~\cite{brown1998kolmogorov} presents a mechanization of this interpretation in the Twelf logical framework, including formalized translations of derivations and proofs of soundness and completeness. However, Twelf lacks certain computational expressiveness and modular reasoning capabilities that are desirable for exploring recursive proof transformations.

In this project, we re-implement Brown's Kolmogorov interpretation in the \textbf{Beluga} proof environment. Beluga offers native support for recursive functions over contextual objects and enables computation over LF terms and derivations. These features allow us to define translations and verify meta-theoretical properties more naturally and effectively.

Our work focuses on the functional translation of classical formulas and derivations, their transformation into intuitionistic proofs, and the verification of soundness and completeness within the Beluga system. Through this implementation, we aim to highlight Beluga’s strengths in mechanizing meta-theoretic reasoning about logic systems.

\section{Approach and Contribution}

\paragraph{Goal.} Our main goal is to formalize Kolmogorov's translation from classical natural deduction to intuitionistic natural deduction in Beluga, and to prove the \textit{soundness} and \textit{completeness} of this translation constructively.

\paragraph{Approach.} We adopt the following methodology:
\begin{enumerate}
    \item Define a functional translation of formulas from classical to intuitionistic logic (Kolmogorov translation) using LF type \textbf{LF ktrans : o -> o -> type} (we call it kolm in paper proof). Also define the inference rules of ktrans to allow derivation.
    \item Prove \textbf{soundness}: every classical derivation (after translation) yields a valid intuitionistic proof of the given translated formula \textbf{ rec sound : Rel [Γ] [Γ'] → [Γ ⊢ knd A[]] → [ ⊢ ktrans A A*] → [Γ' ⊢ nd A*[]]}. It's also based on two lemmas:
    \begin{enumerate}
      \item \textbf{Existence of Kolmogorov Translation}  
      For every formula $A$, there exists an formula $A^*$ such that $\textsf{kolm}(A, A^*)$ holds.  
      \textit{Beluga setup:}
      \begin{verbatim}
      rec existsktrans : {A : [⊢ o]} {A* : [⊢ o]} [⊢ ktrans A A*]
      \end{verbatim}
    
      \item \textbf{Double Negation Property}  
      All Kolmogorov Translation of a formula contains a double negation. 
    \end{enumerate}
    Then we can be free to use Hypothesis Induction, ¬I rule and ¬E rule to prove soundness.
    \item Prove \textbf{completeness}: for every intuitionistic proof of a  translated formula, there exists a corresponding classical derivation. \textbf{rec equiv : Rel [Γ] [Γ'] → [⊢ ktrans A A*] → [Γ ⊢ knd A*[]] → [Γ ⊢ knd A[]]}. It's also based on two lemmas:
    \begin{enumerate}
      \item \textbf{Back-Translation Lemma}  
      If we can prove intuitionistic formula $A$, a proof of classical formula $A$ exists.  
      \textit{Beluga setup:}
      \begin{verbatim}
      rec nj_nk : Rel [Γ] [Γ'] → [Γ' ⊢ nd A[]] → [Γ ⊢ knd A[]]
      \end{verbatim}
    
      \item \textbf{Kolmogorov Equivalence Lemma}  
      If $A^*$ is the Kolmogorov translation of $A$, and $A^*$ is provable in classical natural deduction, thenthen the original formula $A$ is also provable in classical natural deduction.
      \begin{verbatim}
      rec equiv : Rel [Γ] [Γ'] → [⊢ ktrans A A*] → [Γ ⊢ knd A*[]] 
      → [Γ ⊢ knd A[]]
      \end{verbatim}
    \end{enumerate}
    Then all cases of completeness can be proved in the same way by using these two lemmas.
\end{enumerate}

\paragraph{Contribution.} This work contributes:
\begin{itemize}
    \item A mechanized and executable implementation of Kolmogorov translation in Beluga.
    \item Proof of lemmas and inference rules needed using recursive functions.
    \item A constructive proof of soundness and completeness of the Kolmogorov embedding in Beluga.
\end{itemize}
Our Beluga implementation demonstrates the expressiveness and utility of dependently-typed meta-programming for logic translation and proof theory.


\section{Idea}

The key difference between intuitionistic logic and classical logic lies in the acceptance of the law of excluded middle. Our goal is to explore the connection between the two systems, showing that they are essentially equivalent under double negation translation.


\subsection{Nature Deduction}
For the natural deduction we have these rules for
 introduction and elimination.

\[
\infer[\land I]{\vdash A \land B}{\vdash A & \vdash B}
\hspace{3cm}
\infer[\land E_L]{\vdash A}{\vdash A \land B}
\quad
\infer[\land E_R]{\vdash B}{\vdash A \land B}
\]


% Row 2: →I, →E
\[
\infer[\supset I^u]{\vdash A \supset B}{
  \infer*{\vdash B}{\infer [u]{\vdash A}{}}
}
\hspace{3cm}
\infer[\supset E]{\vdash B}{\vdash A \supset B & \vdash A}
\]



% Row 3: ∨I, ∨E
\[
\infer[\lor I_L]{\vdash A \lor B}{\vdash A}
\quad
\infer[\lor I_R]{\vdash A \lor B}{\vdash B}
\hspace{2cm}
\infer[\lor E^{u_1, u_2}]{\vdash C}{
  \vdash A \lor B
  \quad
  \infer*{\vdash C}{\infer[u_1]{\vdash A}{}}
  \quad
  \infer*{\vdash C}{\infer[u_2]{\vdash B}{}}
}
\]

% Row 4: ¬I, ¬E
\[
\infer[\neg I^{p,u}]{\vdash \neg A}{
  \infer*{\vdash \perp}{\infer[u]{\vdash A}{}}
}
\hspace{3cm}
\infer[\neg E]{\vdash C}{
  \vdash A & \vdash \neg A
}
\]

% Row 5: ⊤I, ⊥E
\[
\infer[\top I]{\vdash \top}{}
\hspace{3cm}
\infer[\perp E]{\vdash C}{\vdash \perp}
\]
Natural deduction (ND) corresponds to intuitionistic logic because it does not enforce that every proposition has a fixed complement. For example, if we apply \emph{negation introduction} ($\neg I$) to a proposition $A$ and derive $\neg A$, we cannot simply repeat this process on $\neg A$ to recover $A$. This asymmetry is a key reason why ND is not classical logic.

To extend ND into classical logic, we need to incorporate the law of excluded middle. One way to do this is by adding the \emph{Kolmogorov double negation rule}, which allows us to derive $A$ from $\neg\neg A$. We refer to this rule as $\neg\text{kd}E$ (short for \emph{not Kolmogorov double Elimination}, or \textbf{nkdE}). With this rule added, we define a new system—ND plus the Kolmogorov rule—which we call \textbf{KND}.

To fully complete KND as classical logic, we must also specify the unique complement of $\top$, which is $\bot$. We treat $\bot$ as an atomic formula. With these additions, KND forms a proper classical logic system.

\[
\infer[\neg\neg_{kd}E]{\vdash A}{\vdash \neg\neg A}
\]

\begin{center}
    \fbox{%
  \begin{minipage}{0.8\textwidth}
\[
\infer[\neg\neg E]{\vdash A \lor \neg A}{
  \infer[\neg I^{p,u}]{\vdash \neg\neg(A\lor\neg A)}{
    \infer{\vdash p}{
      % First assumption subproof u
      \infer[u]{\vdash \neg(A\lor\neg A)}{}
      \quad
      % Disjunction introduction on ¬A
      \infer[\lor I_2]{\vdash A \lor \neg A}{
        % Nested negation introduction subproof p,ν
        \infer[\neg I^{p,\nu}]{\vdash \neg A}
        {
          \infer[\neg E]{\vdash p}{
            % Disjunction introduction on A
            \infer[u]{\vdash \neg(A\lor\neg A)}{}
            \quad
            % Reuse assumption u
            \infer[\lor I_1]{\vdash A \lor \neg A}{
              \infer[\nu]{\vdash A}{}
            }
          }
        }
      }
    }
  }
}
\]
\end{minipage}%
}
\\
\vspace{1em}
prove of excluding middle

\end{center}





Now in our hand we have the intuitionistic logic ND
 and classical logic KND. We show that both these two
  logics are "the same" by proving that for any logical formula provable in KND it can also be proven in ND (soundness) and any logical formula provable in ND can also be proven in KND (completeness).

To do this first we need to define a translation function that translates formulas in ND or KND to their counterparts. We use the ktrans--Kolmogorov translation and it is defined as ($n$ for $\neg\neg$):

\begin{align*}
A^* &= nA \quad \text{if } A \text{ is atomic} \\
(A \land B)^* &= n(A^* \land B^*) \\
(A \supset B)^* &= n(A^* \supset B^*) \\
(A \lor B)^* &= n(A^* \lor B^*) \\
(\neg A)^* &= n(\neg A^*) \\
\top^* &= n\top \\
\bot^* &= n\bot
\end{align*}




\section{Inference Rules}
Before we step into the proof of soundness and completeness we need some 
inference rules to help us eliminate double negation in ND.

First, since we can prove $\neg\neg A$ from $A$ in ND we 
have the inference rule $\neg\neg X$. Same with $\neg\neg_{k}X$.

Also we can eliminate $\neg\neg\neg A$ to $\neg A$, we make 
it as $\neg\neg\neg R$.

% First boxed derivation
\[
\infer[\neg I^{p,u}]{\vdash \neg\neg A}{
    \infer[\neg E]{\vdash p}{
        \infer [u]{\vdash \neg A}{} & \vdash A
    }
}
\quad \Rightarrow \quad
\fbox{$
    \infer[\neg \neg X]{\vdash \neg \neg A}{\vdash A}
$}
\]

% Second boxed derivation
\[
\infer[\neg kI^{p,u}]{\vdash \neg\neg A}{
    \infer[\neg kE]{\vdash p}{
        \infer [u]{\vdash \neg A}{} & \vdash A
    }
}
\quad \Rightarrow \quad
\fbox{$
    \infer[\neg \neg kX]{\vdash \neg \neg A}{\vdash A}
$}
\]

% Third boxed derivation
\[
    \infer[\neg I^{q,u}]{\vdash \neg A}{
        \infer[\neg E]{\vdash q}{ 
              \infer[\neg \neg X]{\vdash \neg \neg A}{\infer[u]{\vdash A}{}} &
              \infer[v]{\vdash \neg \neg \neg A}{}
        }
      }
\quad \Rightarrow \quad
\fbox{$
    \infer [\neg \neg \neg R]
    {\vdash \neg A}
    {\vdash \neg\neg \neg A} 
$}
\]

% Fourth boxed derivation
% Fourth boxed derivation  (re‑done for dneg_falser)
\[
\infer[\bot E]{\vdash C}{
  \infer[\neg E]{\vdash p}{
    \vdash \neg\neg\bot
    &
    \infer[\neg I^{u}]{\vdash \neg\bot}{
      \infer[u]{\vdash \bot}{}
    }
  }
}
\quad \Rightarrow \quad
\fbox{$
  \infer[\neg\neg\bot E]{\vdash C}{\vdash \neg\neg\bot}
$}
\]


\section{Lemma}
\begin{lemma}[Existence of Kolmogorov Translation]\label{lem:exists-kolm}
  For every propositional formula $A$ (built from atoms with
  $\neg$, $\land$, $\lor$, and $\supset$), there exists a formula
  $A^{\!*}$—its Kolmogorov translation—such that
  \[
    \operatorname{kolm}(A,A^{\!*})
  \]
  holds.
  \end{lemma}
  
  \begin{proof}
  Define $A^{\!*}$ by structural induction on $A$:
  \[
  \begin{array}{rcl@{\qquad}l}
  p^{\!*}              &\coloneqq& \neg\neg p &(\text{$p$ atomic})\\[4pt]
  (A \land B)^{\!*}    &\coloneqq& \neg\neg\bigl(A^{\!*}\land B^{\!*}\bigr)\\
  (A \lor  B)^{\!*}    &\coloneqq& \neg\neg\bigl(A^{\!*}\lor  B^{\!*}\bigr)\\
  (A \supset B)^{\!*}  &\coloneqq& \neg\neg\bigl(A^{\!*}\supset B^{\!*}\bigr)\\
  (\neg A)^{\!*}       &\coloneqq& \neg\neg\neg A^{\!*}
  \end{array}
  \]
  
  \noindent
  \textbf{Base case.}  If $A$ is atomic ($A=p$), set $A^{\!*}=\neg\neg p$; then
  $\operatorname{kolm}(p,\neg\neg p)$ is immediate.
  
  \smallskip
  \noindent
  \textbf{Inductive step.}  Assume $A^{\!*}$ and $B^{\!*}$ already exist.
  The table above defines translations for each composite constructor,
  and the corresponding $\operatorname{kolm}$ derivations follow from
  the induction hypotheses.
  
  \smallskip
  Since the construction terminates for every syntax tree, the
  mapping $A\mapsto A^{\!*}$ is total; hence
  $\operatorname{kolm}(A,A^{\!*})$ holds for all formulas $A$.
  \end{proof}


  \begin{lemma}[Every Kolmogorov image is a double negation]
    \label{lem:outer-dneg}
    Let $A$ and $B$ be propositional formulas.
    If \(\operatorname{kolm}(A,B)\) holds, then there exists a formula
    \(C\) such that
    \[
       B \;=\; \neg\neg C
       \quad\text{and}\quad
       \operatorname{kolm}(A,C).
    \]
    \end{lemma}
    
    \begin{proof}
    Proceed by induction on the derivation of \(\operatorname{kolm}(A,B)\).
    
    \smallskip
    \emph{Atomic case.}  
    If \(A=p\) and the derivation ends with the rule for atoms, we have
    \(B=\neg\neg p\).  
    Set \(C:=p\).  
    Then \(\operatorname{kolm}(p,C)\) is the very last step of the given
    derivation, so the claim holds.
    
    \smallskip
    \emph{Conjunction.}  
    Suppose \(\operatorname{kolm}(A\land B_0,\,B)\) is derived via
    \[
       B \;=\; \neg\neg\bigl(D_1\land D_2\bigr),
       \qquad
       \operatorname{kolm}(A,D_1),
       \qquad
       \operatorname{kolm}(B_0,D_2).
    \]
    Take \(C := D_1\land D_2\).
    Both sub‑derivations satisfy the induction hypothesis, hence
    \(\operatorname{kolm}(A\land B_0,C)\) holds and
    \(B=\neg\neg C\).
    
    \smallskip
    \emph{Disjunction and implication.}  
    The arguments are identical: each rule in the definition of
    \(\operatorname{kolm}\) produces the outer pattern
    \(\neg\neg(\,\cdot\,)\), so we peel off that pair of negations and
    re‑assemble the inner sub‑translations using the induction hypothesis.
    
    \smallskip
    \emph{Negation.}  
    From \(\operatorname{kolm}(\neg A_0,B)\) we get
    \(B=\neg\neg\neg D\) with \(\operatorname{kolm}(A_0,D)\).
    Let \(C := \neg D\); then again \(B=\neg\neg C\) and
    \(\operatorname{kolm}(\neg A_0,C)\).
    
    \smallskip
    Thus every derivation of \(\operatorname{kolm}(A,B)\) factors through
    an inner formula \(C\) with \(B=\neg\neg C\), proving the claim.
    \end{proof}

    \begin{lemma}[Kolmogorov Equivalence Lemma]
    \label{lem:equiv}
    Let $A$ be a classical formula and $A^*$ its Kolmogorov translation. If $A^*$ is derivable in classical natural deduction, then so is $A$. That is:
    \[
    \text{If } \textsf{kolm}(A, A^*), \text{ and } \vdash_{\textsf{knd}} A^* \text{ then } \vdash_{\textsf{knd}} A.
    \]
    
    \textbf{Proof.}  
    By induction on the derivation of $\textsf{kolm}(A, A^*)$.
    
    \medskip

    \noindent \textbf{Case:} $\textsf{kolm}(A, \neg\neg A)$  
    \[
    \infer[\text{kolm base}]{\textsf{kolm}(A, \neg\neg A)}{}
    \]
    By assumption, $\textsf{knd}(\neg\neg A)$ \hfill (1)\\
    By rule $\textsf{$\neg\neg$ kE}$ on (1), we derive $\textsf{knd}(A)$.
    
    \medskip
    
    \noindent \textbf{Case:} 
    \[
    \infer[\text{kolm$\wedge$}]{\textsf{kolm}(A \wedge B, \neg\neg (A^* \wedge B^*))}{
      \textsf{kolm}(A, A^*) \quad \textsf{kolm}(B, B^*)
    }
    \]
    By assumption, $\textsf{knd}(\neg\neg (A^* \wedge B^*))$ \hfill (1)\\
    By $\textsf{$\neg\neg$ kE}$ on (1), we get $\textsf{knd}(A^* \wedge B^*)$ \hfill (2)\\
    By $\textsf{$\wedge$ kE1}$ on (2), we obtain $\textsf{knd}(A^*)$ \hfill (3)\\
    By $\textsf{$\wedge$ kE2}$ on (2), we obtain $\textsf{knd}(B^*)$ \hfill (4)\\
    By IH on $\textsf{kolm}(A, A^*)$ and (3), we obtain $\textsf{knd}(A)$ \hfill (5)\\
    By IH on $\textsf{kolm}(B, B^*)$ and (4), we obtain $\textsf{knd}(B)$ \hfill (6)\\
    By $\textsf{$\wedge$ kI}$ on (5) and (6), we derive $\textsf{knd}(A \wedge B)$.
    
    \medskip
    
    \noindent \textbf{Case:} 
    \[
    \infer[\text{kolm$\supset$}]{\textsf{kolm}(A \supset B, \neg\neg (A^* \supset B^*))}{
      \textsf{kolm}(A, A^*) \quad \textsf{kolm}(B, B^*)
    }
    \]
    By assumption, $\textsf{knd}(\neg\neg (A^* \supset B^*))$ \hfill (1)\\
    By $\textsf{$\neg\neg$ kE}$ on (1), we obtain $\textsf{knd}(A^* \supset B^*)$ \hfill (2)\\
    Assume $\textsf{knd}(A)$ [for $\supset$kI] \hfill (3)\\
    By the Soundness Lemma on $\textsf{kolm}(A, A^*)$ and (3), we obtain $\textsf{nd}(A^*)$ \hfill (4)\\
    By the Back-Translation Lemma on (4), we obtain $\textsf{knd}(A^*)$ \hfill (5)\\
    Apply $\textsf{$\supset$ kE}$ to (2) and (5), we get $\textsf{knd}(B^*)$ \hfill (6)\\
    By IH on $\textsf{kolm}(B, B^*)$ and (6), we get $\textsf{knd}(B)$ \hfill (7)\\
    By $\textsf{$\supset$ kI}$ on assumption (3) ⟶ (7), we derive $\textsf{knd}(A \supset B)$.
    
    \medskip
    
    \noindent \textbf{Case:} 
    \[
    \infer[\text{kolm$\vee$}]{\textsf{kolm}(A \vee B, \neg\neg (A^* \vee B^*))}{
      \textsf{kolm}(A, A^*) \quad \textsf{kolm}(B, B^*)
    }
    \]
    By assumption, $\textsf{knd}(\neg\neg (A^* \vee B^*))$ \hfill (1)\\
    By $\textsf{$\neg\neg$ kE}$ on (1), we get $\textsf{knd}(A^* \vee B^*)$ \hfill (2)\\
    Perform case analysis on (2):\\
    \quad If $\textsf{$\vee$ kIl}$ gives $\textsf{knd}(A^*)$ \hfill (3)\\
    \quad \quad By IH on $\textsf{kolm}(A, A^*)$ and (3), we get $\textsf{knd}(A)$ \hfill (4)\\
    \quad \quad Apply $\textsf{$\vee$ kIl}$ to (4), we obtain $\textsf{knd}(A \vee B)$\\
    \quad If $\textsf{$\vee$ kIr}$ gives $\textsf{knd}(B^*)$ \hfill (5)\\
    \quad \quad By IH on $\textsf{kolm}(B, B^*)$ and (5), we get $\textsf{knd}(B)$ \hfill (6)\\
    \quad \quad Apply $\textsf{$\vee$ kIr}$ to (6), we obtain $\textsf{knd}(A \vee B)$
    
    \medskip
    
    \noindent \textbf{Case:} 
    \[
    \infer[\text{kolm$\neg$}]{\textsf{kolm}(\neg A, \neg\neg\neg A^*)}{
      \textsf{kolm}(A, A^*)
    }
    \]
    By assumption, $\textsf{knd}(\neg\neg\neg A^*)$ \hfill (1)\\
    Apply $\textsf{$\neg\neg$ kE}$ on (1), we obtain $\textsf{knd}(\neg A^*)$ \hfill (2)\\
    Assume $\textsf{knd}(A)$ [for $\neg$kI] \hfill (3)\\
    By the Soundness Lemma on $\textsf{kolm}(A, A^*)$ and (3), we obtain $\textsf{nd}(A^*)$ \hfill (4)\\
    By the Back-Translation Lemma on (4), we obtain $\textsf{knd}(A^*)$ \hfill (5)\\
    Apply $\textsf{$\neg$ kE}$ on (2) and (5), we derive $\textsf{knd}(\bot)$ \hfill (6)\\
    By $\textsf{$\neg$ kI}$ on assumption (3) ⟶ (6), we conclude $\textsf{knd}(\neg A)$
    
    \medskip
    
    \noindent \textbf{Case:} 
    \[
    \textsf{kolm}(\top, \neg\neg \top)
    \]
    By assumption, $\textsf{knd}(\neg\neg \top)$ \hfill (1)\\
    Apply $\textsf{$\neg\neg$ kE}$ on (1), we obtain $\textsf{knd}(\top)$
    
    \medskip
    
    \noindent \textbf{Case:} 
    \[
    \textsf{kolm}(\bot, \neg\neg \bot)
    \]
    By assumption, $\textsf{knd}(\neg\neg \bot)$ \hfill (1)\\
    Apply $\textsf{$\neg\neg$ kE}$ on (1), we obtain $\textsf{knd}(\bot)$
    \end{lemma}
    



\section{Soundness}
lemma 1: nd A -> knd A
lemma 2: if have ktrans A A* then if we can proof knd A* then we can proof nd A

Now with the help of our derivation rule, and lemma we can prove our soundness theorem. We do structural proof on the last used operation.

\text{Case:}
\vspace{3em}
\[
\infer[\land kI]{A \land^k B}{A & B}
\quad \Rightarrow \quad
\infer[\neg\neg X]{\neg\neg(\neg\neg A \land \neg\neg B)}{
    \infer[\land I]{\neg\neg A \land \neg\neg B}{
      \neg\neg A & \neg\neg B
    }
}
\]

\vspace{3em}
\text{Case:}
\[
\infer[\land kE1]{A}{
  A \land^k B
}
\quad \Rightarrow \quad
\infer[\neg I^{p,v}]{ \neg \neg A}{ 
  \infer[\neg E]{ p}{
    \infer[u]{
        \neg \neg (\neg \neg A \land \neg \neg B)
     }{}
     \infer[]{
        \neg (\neg \neg A \land \neg \neg B)
     }{
        \infer[\neg I^{q,u}]{ q}{
            \infer[\land E1]{\neg \neg A }{
                \infer[u]{\neg \neg A \land \neg \neg B}{}
            }
            \infer[v]{\neg A}{}
        }
     }
  }
}
\]

\vspace{3em}
\text{Case:}
\[
\infer[\land kE2]{B}{
  A \land^k B
}
\quad \Rightarrow \quad
\infer[\neg I^{p,v}]{\neg \neg B}{ 
  \infer[\neg E]{p}{
    \infer[u]{
        \neg \neg (\neg \neg A \land \neg \neg B)
     }{}
     \infer[]{
        \neg (\neg \neg A \land \neg \neg B)
     }{
        \infer[\neg I^{q,u}]{ q}{
            \infer[\land E2]{\neg \neg B }{
                \infer[u]{\neg \neg A \land \neg \neg B}{}
            }
            \infer[v]{\neg B}{}
        }
     }
  }
}
\]

\vspace{3em}
\text{Case:}
\[
\infer[\supset k I^u]{A \supset^k B}{
  \infer*[]{B}{
    \infer[u]{A}{}
  }
}
\quad \Rightarrow \quad
\infer[\neg \neg X ] {\neg \neg(\neg \neg A \supset \neg \neg B )}{
\infer[\supset  I^u]{\neg \neg A \supset \neg \neg B}{
  \infer*[]{\neg \neg B}{
    \infer[u]{\neg \neg A}{}
  }
}
}
\]

\vspace{3em}
\text{Case:}
\[
\infer[\supset kE]{B}{
    A \supset^k B & A
}
\quad \Rightarrow \quad
\infer[\neg I^{q,v}] {\neg \neg B }{
\infer[\neg E]{q}{
    \infer[u]{\neg \neg(\neg \neg A \supset \neg \neg B )}{}
    \infer[\neg I^{p,u}]{\neg(\neg \neg A \supset \neg \neg B )}{
        \infer[\neg E]{p}{
            \infer[\supset E]{\neg \neg B}{
                \infer[u]{\neg \neg A \supset \neg \neg B}{}
                {\neg \neg A}
            }
            \infer[v]{\neg B}{}
        }
    }
}
}
\]


\vspace{3em}
\text{Case:}
\[
\infer[\lor kI1]{A \lor^k B}{A}
\quad \Rightarrow \quad
\infer[\neg \neg X]{\neg \neg(\neg \neg A \lor \neg \neg B)}{
    \infer[\lor I1]{\neg \neg A \lor \neg \neg B}{\neg \neg A
        \infer[]{}{}
    }
}
\]

\vspace{3em}
\text{Case:}
\[
\infer[\lor kI2]{A \lor^k B}{B}
\quad \Rightarrow \quad
\infer[\neg \neg X]{\neg \neg(\neg \neg A \lor \neg \neg B)}{
    \infer[\lor I2]{\neg \neg A \lor \neg \neg B}{\neg \neg B
        \infer[]{}{}
    }
}
\]


\vspace{3em}
\text{Case:}
\[
\infer[\lor kE^{u,v}]{C}{
    {A \lor^{k} B}
    \hspace{2em}
    \infer*[]{C}{\infer[u]{A}{}}
    \hspace{2em}
    \infer*[]{C}{\infer[v]{B}{}}
}
\quad\Longrightarrow\quad
\infer[\lor E^{u,v}]{\neg\neg C}{
    \infer[\neg\neg E]{\neg\neg A \;\lor\; \neg\neg B}{
        \neg\neg\!\bigl(\neg\neg A \lor \neg\neg B\bigr)}
    \hspace{2em}
    \infer*[]{\neg\neg C}{
        \infer[u]{\neg\neg A}{}}
    \hspace{2em}
    \infer*[]{\neg\neg C}{
        \infer[v]{\neg\neg B}{}}
}
\]





\vspace{3em}
\text{Case:}
\[
\infer[\neg\neg E]{A}{
    \neg\neg A
}
\quad \Rightarrow \quad
\infer[\neg\neg\neg R]{\neg \neg A}{
    \neg\neg\neg\neg A
}
\]

\vspace{3em}
\text{Case:}
\[
\infer[\neg\neg E]{A}{
    \neg\neg A
}
\quad \Rightarrow \quad
\infer[\neg\neg\neg R]{\neg \neg A}{
    \neg\neg\neg\neg A
}
\]



















\section{Completeness}

We now prove that if the Kolmogorov translation $A^*$ of a classical formula $A$ is provable intuitionistically, then $A$ is also classically provable. That is, Kolmogorov translation is complete with respect to classical provability.


\label{lem:completeness}
If $\textsf{nd}(A^*)$ and $\textsf{kolm}(A, A^*)$, then $\textsf{knd}(A)$.


\begin{proof}
By assumption, we are given:
\begin{itemize}
    \item $\textsf{nd}(A^*)$ \hfill (1)
    \item $\textsf{kolm}(A, A^*)$ \hfill (2)
\end{itemize}

Apply the Back-Translation Lemma to (1), we obtain:
\[
\textsf{knd}(A^*) \hfill (3)
\]

Then apply the Kolmogorov Equivalence Lemma (Lemma~\ref{lem:equiv}) to (2) and (3), yielding:
\[
\textsf{knd}(A)
\]

This concludes the proof.
\end{proof}





\section{Beluga}
\begin{lstlisting}
  i : type. % Type of individuals; we leave elements abstract.

  LF o : type =  % formulas
    | ⊃ : o -> o -> o
    | ⊤ : o
    | ⊥ : o
    | ∧   : o → o → o
    | ∨   : o → o → o
    | ¬  : o -> o
    | ∀  : (i → o) → o     % ∀ \x. A(x) ⊃ B    ∀ \x. A(x) ⊃ B(x) 
    | ∃  : (i → o) → o     % ∃ \x. A(x) ⊃ B    ∃ \x. A(x) ⊃ B(x) 
  ;
  
  --prefix ¬ 10. 
  --infix ∧ 6 right. 
  --infix ∨ 5 right. 
  --infix ⊃ 4 right.
  --prefix ∀ 8. 
  --prefix ∃ 8.
  
  
  LF nd : o -> type = 
    | ⊃I : (nd A -> nd B)
     -> nd (A ⊃ B)
           
    | ⊃E : nd (A ⊃ B) -> nd A 			  
     -> nd B
           
    | ¬I : ({p:o} nd A -> nd p)
     -> nd (¬ A)
           
    | ¬E : nd (¬ A) -> nd A
     -> nd C
           
    | ∧I : nd A → nd B
     → nd  (A ∧ B)
           
    | ∧El : nd (A ∧ B)
      → nd A
  
    | ∧Er : nd (A ∧ B)
      → nd B
  
    | ∨Il : nd A
      → nd (A ∨ B)
    | ∨Ir : nd B → nd (A ∨ B)
    | ∨E  :  nd (A ∨ B)
          → (nd A → nd C)
          → (nd B → nd C)        
          → nd C
    | ⊤I : nd ⊤
    | ⊥E : nd ⊥
           → nd C
  ;
  
     
  LF knd : o → type = 
    | ⊃kI : (knd A → knd B)
           → knd (A ⊃ B)
    
    | ⊃kE : knd (A ⊃ B) → knd A
            → knd B
    
    | ∧kI   : knd A → knd B
           → knd (A ∧ B)
    
    | ∧kEl  : knd (A ∧ B)
           → knd A
    
    | ∧kEr  : knd (A ∧ B)
           → knd B
    
    | ∨kIl  : knd A
           → knd (A ∨ B)
    
    | ∨kIr  : knd B
           → knd (A ∨ B)
    
    | ∨kE   : knd (A ∨ B)
           → (knd A → knd C)
           → (knd B → knd C)
           → knd C
    
    | ⊤kI   : knd ⊤
    
    | ⊥kE : knd ⊥
           → knd C
    
    | ¬kI   : ({p:o} knd A → knd p)
              → knd (¬ A)
  
    | ¬kE : knd (¬ A) -> knd A
           -> knd C
               
    | ¬¬kE  : knd (¬ (¬ A))
              → knd A
  ;
  
  LF ktrans : o -> o -> type =
    | ktrans_∧I : ktrans A A* -> ktrans B B* -> 
                 ktrans (A ∧ B) (¬ (¬ (A* ∧ B*)))
  
    | ktrans_∧El : ktrans (A ∧ B) (¬ (¬ (A* ∧ B*))) ->
                   ktrans A A*
  
    | ktrans_∧Er : ktrans (A ∧ B) (¬ (¬ (A* ∧ B*))) ->
                   ktrans B B*
  
    | ktrans_⊃I : ktrans A A* -> ktrans B B* -> 
                 ktrans (A ⊃ B) (¬ (¬ (A* ⊃ B*)))
  
    | ktrans_⊃E : ktrans (A ⊃ B) (¬ (¬ (A* ⊃ B*))) -> ktrans A A* ->
                 ktrans B B*
  
    | ktrans_∨I : ktrans A A* -> ktrans B B* -> 
                 ktrans (A ∨ B) (¬ (¬ (A* ∨ B*)))
    
    | ktrans_∨E : ktrans (A ∨ B) (¬ (¬ (A* ∨ B*))) -> ktrans A A* -> ktrans B B* -> ktrans C C* ->
                 ktrans C C*
  
    | ktrans_¬I : ktrans A A* ->
                 ktrans (¬ A) (¬ (¬ (¬ A*)))
    
    | ktrans_¬E : ktrans (¬ A) (¬ (¬ (¬ A*))) -> ktrans A A* -> ktrans C C* ->
                 ktrans C C*
  
    | ktrans_⊤ : ktrans ⊤ (¬ (¬ ⊤))
    
    | ktrans_⊥ : ktrans ⊥ (¬ (¬ ⊥))
  ;
  
  %{
  
  Translation context
  
  }%
  schema ctx = knd A ;
  schema nctx = nd A ;
  
  inductive Rel : {Γ:ctx} {Γ' : nctx} ctype =
    | empty : Rel [ ] [ ]
    | cons  : Rel [Γ] [Γ']
              → Rel [Γ, a:knd A[]] [Γ', a:nd A[]];
  
  rec ktrans_of : [⊢ o] → [⊢ o] =
  fn A =>
    case A of
      | [⊢ A1 ∧ B1] =>
          let [⊢ A1*] = ktrans_of [⊢ A1] in
          let [⊢ B1*] = ktrans_of [⊢ B1] in
          [⊢ ¬ (¬ (A1* ∧ B1*))]
      | [⊢ A1 ⊃ B1] =>
          let [⊢ A1*] = ktrans_of [⊢ A1] in
          let [⊢ B1*] = ktrans_of [⊢ B1] in
          [⊢ ¬ (¬ (A1* ⊃ B1*))]
      | [⊢ A1 ∨ B1] =>
          let [⊢ A1*] = ktrans_of [⊢ A1] in
          let [⊢ B1*] = ktrans_of [⊢ B1] in
          [⊢ ¬ (¬ (A1* ∨ B1*))]
      | [⊢ ¬ A1] =>
          let [⊢ A1*] = ktrans_of [⊢ A1] in
          [⊢ ¬ (¬ (¬ A1*))]
      | [⊢ ⊤] =>
          [⊢ ¬ (¬ ⊤)]
      | [⊢ ⊥] =>
          [⊢ ¬ (¬ ⊥)]
      
  ;
  
  rec existsktrans : {A : [⊢ o]} {A* : [⊢ o]} [⊢ ktrans A A*] = 
  mlam A => mlam A* =>
    case [⊢ A] of
    | [⊢ A1 ∧ B1] =>
      (case [⊢ A*] of
      | [⊢  ¬ (¬ (A1* ∧ B1*))] =>
        let [⊢ KA] = existsktrans [⊢ A1] [⊢ A1*] in
        let [⊢ KB] = existsktrans [⊢ B1] [⊢ B1*] in
        [⊢ ktrans_∧I KA KB])
    | [⊢ A1 ⊃ B1] =>
      (case [⊢ A*] of
      | [⊢  ¬ (¬ (A1* ⊃ B1*))] =>
        let [⊢ KA] = existsktrans [⊢ A1] [⊢ A1*] in
        let [⊢ KB] = existsktrans [⊢ B1] [⊢ B1*] in
        [⊢ ktrans_⊃I KA KB])
    | [⊢ A1 ∨ B1] =>
      (case [⊢ A*] of
      | [⊢  ¬ (¬ (A1* ∨ B1*))] =>
        let [⊢ KA] = existsktrans [⊢ A1] [⊢ A1*] in
        let [⊢ KB] = existsktrans [⊢ B1] [⊢ B1*] in
        [⊢ ktrans_∨I KA KB])
    | [⊢ ¬ A1] =>
      (case [⊢ A*] of
      | [⊢  ¬ (¬ (¬ A1*))] =>
        let [⊢ KA] = existsktrans [⊢ A1] [⊢ A1*] in
        [⊢ ktrans_¬I KA])
    | [⊢ ⊤] =>
      (case [⊢ A*] of
      | [⊢ ¬ (¬ ⊤)] =>
        [⊢ ktrans_⊤])
    | [⊢ ⊥] =>
      (case [⊢ A*] of
      | [⊢ ¬ (¬ ⊥)] =>
        [⊢ ktrans_⊥])
  ;
  
  rec dnotx : Rel [Γ] [Γ'] → [Γ' ⊢ nd A] → [Γ' ⊢ nd (¬ (¬ A))] =
  fn rel => fn prf =>
    let [Γ' ⊢ D[]] = prf in
    [Γ' ⊢ ¬I (\p. \u. ¬E u D[])]
  ;
  
  rec triple_neg_red : Rel [Γ] [Γ'] → [Γ' ⊢ nd (¬ (¬ (¬ A[])))] → [Γ' ⊢ nd (¬ A[])] =
  fn rel => fn prf =>
    let [Γ' ⊢ D[]] = prf in
    [Γ' ⊢ ¬I (\p. \u. ¬E D[] (¬I (\q. \v. ¬E v u)))]
  ;
  
  rec dneg_falser : Rel [Γ] [Γ'] → [Γ' ⊢ nd (¬ (¬ ⊥))] → [Γ' ⊢ nd C[]] =
  fn rel => fn prf =>
    let [Γ' ⊢ D[]] = prf in
    [Γ' ⊢ ¬E D[] (¬I \p. \u. (⊥E u))]
  ;
  
  rec sound : Rel [Γ] [Γ'] → [Γ ⊢ knd A[]] → [ ⊢ ktrans A A*] → [Γ' ⊢ nd A*[]] =
  fn rel => fn prf => fn kolm =>
    case (prf, kolm) of
    | ([Γ ⊢ ∧kI NKA NKB], [ ⊢ ktrans_∧I KA KB]) =>
      let [Γ' ⊢ NJA] = sound rel [Γ ⊢ NKA] [ ⊢ KA] in
      let [Γ' ⊢ NJB] = sound rel [Γ ⊢ NKB] [ ⊢ KB] in
      dnotx rel [Γ' ⊢ ∧I NJA NJB]
    | ([Γ ⊢ ∧kEl (NK1 : knd (A[] ∧ B[]))], [⊢ (KA : (ktrans A (¬(¬ A**))))]) =>
      let [⊢ B*] = ktrans_of [⊢ B] in
      let [⊢ KB] = existsktrans [⊢ B] [⊢ B*] in
      let [Γ' ⊢ NJ1[]] = sound rel [Γ ⊢ NK1] [⊢ ktrans_∧I KA KB] in
      [Γ' ⊢ ¬I (\p. \u.
        ¬E NJ1[] (
          ¬I (\q. \v.
            ¬E (∧El v) u)))]
    | ([Γ ⊢ ∧kEr (NK1 : knd (A[] ∧ B[]))], [⊢ (KB : (ktrans B (¬(¬ B**))))]) =>
      let [⊢ A*] = ktrans_of [⊢ A] in
      let [⊢ KA] = existsktrans [⊢ A] [⊢ A*] in
      let [Γ' ⊢ NJ1[]] = sound rel [Γ ⊢ NK1] [⊢ ktrans_∧I KA KB] in
      [Γ' ⊢ ¬I (\p. \u.
        ¬E NJ1[] (
          ¬I (\q. \v.
            ¬E (∧Er v) u)))]
    | ([Γ ⊢ ⊃kI \u. (NKB : knd B[])], [⊢ ktrans_⊃I (KA : (ktrans A A*)) (KB : (ktrans B B*))]) =>
      let [Γ', v:nd A*[] ⊢ v] = sound (cons rel) [Γ, u:knd A[] ⊢ u] [⊢ KA] in
      let [Γ', v:nd A*[] ⊢ NJB] = sound (cons rel) [Γ, u:knd _ ⊢ NKB] [⊢ KB] in
      dnotx rel [Γ' ⊢ ⊃I \u. NJB]
    | ([Γ ⊢ ⊃kE (NKI : knd (A[] ⊃ B[])) (NKA : knd A[])], [⊢ (KB : (ktrans B (¬(¬ B**))))]) =>
      let [⊢ A*] = ktrans_of [⊢ A] in
      let [⊢ KA] = existsktrans [⊢ A] [⊢ A*] in
      let [Γ' ⊢ NJA[]] = sound rel [Γ ⊢ NKA] [⊢ KA] in
      let [Γ' ⊢ NJI[]] = sound rel [Γ ⊢ NKI] [⊢ ktrans_⊃I KA KB] in
      [Γ' ⊢ ¬I (\p. \u.
        ¬E NJI[] (
          ¬I (\q. \v. 
            ¬E (⊃E v NJA[]) u)))]
    | ([Γ ⊢ ∨kIl NK], [⊢ ktrans_∨I KA KB]) =>
      let [Γ' ⊢ NJ] = sound rel [Γ ⊢ NK] [⊢ KA] in
      dnotx rel [Γ' ⊢ ∨Il NJ]
    | ([Γ ⊢ ∨kIr NK], [⊢ ktrans_∨I KA KB]) =>
      let [Γ' ⊢ NJ] = sound rel [Γ ⊢ NK] [⊢ KB] in
      dnotx rel [Γ' ⊢ ∨Ir NJ]
    | ([Γ ⊢ ∨kE (NK[] : knd (A[] ∨ B[])) (\ua. NKA[]) (\ub. NKB[])],[⊢ ktrans_∨E (KO : (ktrans (A ∨ B) (¬ (¬ (¬(¬ A**) ∨ ¬(¬ B**)))))) (KA : (ktrans A (¬(¬ A**)))) (KB : (ktrans B (¬(¬ B**)))) (KC : (ktrans C (¬(¬ C**))))]) =>
      let [Γ' ⊢ NJ[]] = sound rel [Γ ⊢ NK[]] [⊢ KO] in
      let [Γ', va:nd (¬(¬ A**[])) ⊢ va] = sound (cons rel) [Γ, ua:knd A[] ⊢ ua] [⊢ KA] in
      let [Γ', vb:nd (¬(¬ B**[])) ⊢ vb] = sound (cons rel) [Γ, ub:knd B[] ⊢ ub] [⊢ KB] in
      let [Γ', va:nd (¬(¬ A**[])) ⊢ NJA[]] = sound (cons rel) [Γ, ua:knd A[] ⊢ NKA[]] [⊢ KC] in
      let [Γ', vb:nd (¬(¬ B**[])) ⊢ NJB[]] = sound (cons rel) [Γ, ub:knd B[] ⊢ NKB[]] [⊢ KC] in
      [Γ' ⊢ ¬I (\p. \u.
        ¬E NJ[] (
          ¬I (\q. \v.
            ¬E (∨E v (\va. NJA[]) (\vb.NJB[])) u)))]
    %{| ([Γ ⊢ ¬kI \p. \u. NK1], [⊢ ktrans_¬I (K : (ktrans A A*))]) =>
      let [⊢ kp] = existsktrans [⊢ ⊥] [⊢ ¬ (¬ ⊥)] in
      let [Γ', v: nd A*[] ⊢ v] = sound (cons rel) [Γ, u:knd A[] ⊢ u] [⊢ K] in
      let [Γ', v: nd A*[] ⊢ NJ1[..,_,_]] = sound (cons rel) [Γ, u: knd A[] ⊢ NK1[..,⊥,_]] [⊢ kp] in
      let [Γ' ⊢ NJ1N[]] = dneg_falser rel [Γ'⊢ NJ1] in
      dnotx rel [Γ' ⊢ ¬I (\p. \u. NJ1N[..,p])]}%
    | ([Γ ⊢ ¬kE NK1[] (NK2[] : knd A[])], [⊢ ktrans_¬E (KN : (ktrans (¬ A) (¬ (¬ (¬ A*))))) (KA : (ktrans A A*)) (KC : (ktrans C C*))]) =>
      let [Γ' ⊢ NJ1] = sound rel [Γ ⊢ NK1[]] [⊢ KN] in
      let [Γ' ⊢ NJ2] = sound rel [Γ ⊢ NK2[]] [⊢ KA] in
      let [Γ' ⊢ NJ1'] = triple_neg_red rel [Γ' ⊢ NJ1] in
      [Γ' ⊢ ¬E NJ1' NJ2]
  ;
  
  rec nj_nk : Rel [Γ] [Γ'] → [Γ' ⊢ nd A[]] → [Γ ⊢ knd A[]] = 
  fn rel => fn prf =>
    case prf of
    | [Γ' ⊢ ∧I NJA NJB] =>
      let [Γ ⊢ NKA] = nj_nk rel [Γ' ⊢ NJA] in
      let [Γ ⊢ NKB] = nj_nk rel [Γ' ⊢ NJB] in
      [Γ ⊢ ∧kI NKA NKB]
    | [Γ' ⊢ ∧El NJ] =>
      let [Γ ⊢ NK] = nj_nk rel [Γ' ⊢ NJ] in
      [Γ ⊢ ∧kEl NK]
    | [Γ' ⊢ ∧Er NJ] =>
      let [Γ ⊢ NK] = nj_nk rel [Γ' ⊢ NJ] in
      [Γ ⊢ ∧kEr NK]
    | [Γ' ⊢ ⊃I \u. NJ] =>
      let [Γ, a: knd A[] ⊢ NK] = nj_nk (cons rel) [Γ', a:nd _ ⊢ NJ] in
      [Γ ⊢ ⊃kI \u. NK]
    | [Γ' ⊢ ⊃E NJI NJA] =>
      let [Γ ⊢ NKI] = nj_nk rel [Γ' ⊢ NJI] in
      let [Γ ⊢ NKA] = nj_nk rel [Γ' ⊢ NJA] in
      [Γ ⊢ ⊃kE NKI NKA]
    | [Γ' ⊢ ∨Il NJ] =>
      let [Γ ⊢ NK] = nj_nk rel [Γ' ⊢ NJ] in
      [Γ ⊢ ∨kIl NK]
    | [Γ' ⊢ ∨Ir NJ] =>
      let [Γ ⊢ NK] = nj_nk rel [Γ' ⊢ NJ] in
      [Γ ⊢ ∨kIr NK]
    | [Γ' ⊢ ∨E NJ (\ua. NJ1) (\ub. NJ2)] =>
      let [Γ ⊢ NK] = nj_nk rel [Γ' ⊢ NJ] in
      let [Γ, a: knd A[] ⊢ NK1] = nj_nk (cons rel) [Γ', a:nd _ ⊢ NJ1] in
      let [Γ, a: knd B[] ⊢ NK2] = nj_nk (cons rel) [Γ', a:nd _ ⊢ NJ2] in
      [Γ ⊢ ∨kE NK (\va.NK1) (\vb.NK2)]
    %{| [Γ' ⊢ ¬I \p. \u. NJ] =>
      let [Γ, a: knd A[] ⊢ NK] = nj_nk (cons rel) [Γ', a:nd _ ⊢ NJ[..]] in
      [Γ' ⊢ ⊃kI \q. \v. NK]}%
    | [Γ' ⊢ ¬E NJ1 NJ2] =>
      let [Γ ⊢ NK1] = nj_nk rel [Γ' ⊢ NJ1] in
      let [Γ ⊢ NK2] = nj_nk rel [Γ' ⊢ NJ2] in
      [Γ ⊢ ¬kE NK1 NK2]
  ;
  
  rec equiv : Rel [Γ] [Γ'] → [⊢ ktrans A A*] → [Γ ⊢ knd A*[]] → [Γ ⊢ knd A[]] =
  fn rel => fn kolm => fn prf =>
    case (kolm, prf) of
    | ([⊢ ktrans_∧I KA KB], [Γ ⊢ (u : knd (¬(¬(A* ∧ B*))))]) =>
      let [Γ ⊢ NKA] = equiv rel [⊢ KA] [Γ ⊢ ∧kEl (¬¬kE u)] in 
      let [Γ ⊢ NKB] = equiv rel [⊢ KB] [Γ ⊢ ∧kEr (¬¬kE u)] in
      [Γ ⊢ ∧kI NKA NKB]
  ;
\end{lstlisting}



















\bibliographystyle{plain}  
\bibliography{references}  
\end{document}